From 15b3cf6f4a325d8243a1cc3ebb020f117bb5b148 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Kasper=20Ga=C5=82kowski?= <kpg@posteo.net>
Date: Tue, 17 Aug 2021 20:31:01 +0200
Subject: [PATCH] add gzip decompression for working with bcache

---
 src/libutil/compression.cc | 59 ++++++++++++++++++++++++++++++++++++++
 src/libutil/local.mk       |  2 +-
 2 files changed, 60 insertions(+), 1 deletion(-)

diff --git a/src/libutil/compression.cc b/src/libutil/compression.cc
index 0dd84e320..826c7bcb2 100644
--- a/src/libutil/compression.cc
+++ b/src/libutil/compression.cc
@@ -5,6 +5,7 @@
 
 #include <lzma.h>
 #include <bzlib.h>
+#include <zlib.h>
 #include <cstdio>
 #include <cstring>
 
@@ -198,6 +199,62 @@ struct BrotliDecompressionSink : ChunkedCompressionSink
     }
 };
 
+struct GzipDecompressionSink : ChunkedCompressionSink
+{
+    Sink & nextSink;
+    z_stream strm;
+    bool finished = false;
+
+    GzipDecompressionSink(Sink & nextSink) : nextSink(nextSink)
+    {
+        strm.zalloc = Z_NULL;
+        strm.zfree = Z_NULL;
+        strm.opaque = Z_NULL;
+        strm.avail_in = 0;
+        strm.next_in = Z_NULL;
+        int ret = inflateInit2(&strm, 16+MAX_WBITS);
+        if (ret != Z_OK)
+            throw CompressionError("unable to initialise gzip decoder");
+
+        strm.next_out = outbuf;
+        strm.avail_out = sizeof(outbuf);
+    }
+
+    ~GzipDecompressionSink()
+    {
+        inflateEnd(&strm);
+    }
+
+    void finish() override
+    {
+        flush();
+        write(nullptr, 0);
+    }
+
+    void writeInternal(const unsigned char * data, size_t len) override
+    {
+        strm.next_in = (unsigned char *)data;
+        strm.avail_in = len;
+
+        while (!finished && (!data || strm.avail_in)) {
+            checkInterrupt();
+
+            int ret = inflate(&strm, data ? Z_NO_FLUSH : Z_FINISH);
+            if (ret != Z_OK && ret != Z_STREAM_END)
+                throw CompressionError("error while decompressing gzip file");
+
+            finished = ret == Z_STREAM_END;
+
+            if (strm.avail_out < sizeof(outbuf) || strm.avail_in == 0) {
+                nextSink(outbuf, sizeof(outbuf) - strm.avail_out);
+                strm.next_out = outbuf;
+                strm.avail_out = sizeof(outbuf);
+            }
+        }
+    }
+};
+
+
 ref<std::string> decompress(const std::string & method, const std::string & in)
 {
     StringSink ssink;
@@ -217,6 +274,8 @@ ref<CompressionSink> makeDecompressionSink(const std::string & method, Sink & ne
         return make_ref<BzipDecompressionSink>(nextSink);
     else if (method == "br")
         return make_ref<BrotliDecompressionSink>(nextSink);
+    else if (method == "gzip")
+        return make_ref<GzipDecompressionSink>(nextSink);
     else
         throw UnknownCompressionMethod("unknown compression method '%s'", method);
 }
diff --git a/src/libutil/local.mk b/src/libutil/local.mk
index e41a67d1f..dcdc88daf 100644
--- a/src/libutil/local.mk
+++ b/src/libutil/local.mk
@@ -6,4 +6,4 @@ libutil_DIR := $(d)
 
 libutil_SOURCES := $(wildcard $(d)/*.cc)
 
-libutil_LDFLAGS = $(LIBLZMA_LIBS) -lbz2 -pthread $(OPENSSL_LIBS) $(LIBBROTLI_LIBS) $(BOOST_LDFLAGS) -lboost_context
+libutil_LDFLAGS = -lz $(LIBLZMA_LIBS) -lbz2 -pthread $(OPENSSL_LIBS) $(LIBBROTLI_LIBS) $(BOOST_LDFLAGS) -lboost_context
-- 
2.31.1

